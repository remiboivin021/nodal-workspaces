import yaml
from pathlib import Path
from collections import defaultdict

DOCS_DIR = Path("docs")
OUTPUT_FILE = Path("docs/NAVIGATION.md")

class DocError(Exception):
    pass

class Page:
    def __init__(self, title, parent, nav_order, path):
        self.title = title
        self.parent = parent
        self.nav_order = nav_order
        self.path = path
        self.is_index = path.name == "index.md"

def load_pages():
    pages = {}
    for md in DOCS_DIR.rglob("*.md"):
        # Ignorer le fichier de navigation gÃ©nÃ©rÃ©
        if md == OUTPUT_FILE:
            continue
            
        with md.open() as f:
            content = f.read()
        
        if not content.startswith("---"):
            raise DocError(f"Missing frontmatter in {md}")
        
        parts = content.split("---", 2)
        if len(parts) < 3:
            raise DocError(f"Malformed frontmatter in {md}")
        
        fm_text = parts[1]
        
        # VÃ©rifier les clÃ©s dupliquÃ©es
        lines = fm_text.strip().split('\n')
        keys_seen = defaultdict(list)
        for line_num, line in enumerate(lines, 1):
            if ':' in line and not line.strip().startswith('#'):
                key = line.split(':', 1)[0].strip()
                keys_seen[key].append(line_num)
        
        duplicates = {k: v for k, v in keys_seen.items() if len(v) > 1}
        if duplicates:
            dup_details = ", ".join([f"'{k}' (lines {v})" for k, v in duplicates.items()])
            raise DocError(f"Duplicate frontmatter keys in {md}: {dup_details}")
        
        fm = yaml.safe_load(fm_text)
        
        title = fm.get("title")
        nav_order = fm.get("nav_order")
        parent = fm.get("parent")
        
        if not title or nav_order is None:
            raise DocError(f"Missing title or nav_order in {md}")
        
        if title in pages:
            raise DocError(f"Duplicate title '{title}' in {md} and {pages[title].path}")
        
        pages[title] = Page(title, parent, nav_order, md)
    
    return pages

def validate_parents(pages):
    for page in pages.values():
        if page.parent:
            if page.parent not in pages:
                raise DocError(f"Parent '{page.parent}' not found for {page.path}")
            if page.parent == page.title:
                raise DocError(f"Page cannot be its own parent: {page.title}")

def detect_cycles(pages):
    def visit(title, stack):
        if title in stack:
            raise DocError(f"Cycle detected: {' -> '.join(stack + [title])}")
        page = pages[title]
        if page.parent:
            visit(page.parent, stack + [title])
    
    for title in pages:
        visit(title, [])

def validate_nav_order(pages):
    children = defaultdict(list)
    for page in pages.values():
        parent = page.parent or "__ROOT__"
        children[parent].append(page)
    
    for parent, group in children.items():
        seen = {}
        for page in group:
            if page.nav_order in seen:
                other = seen[page.nav_order]
                parent_display = parent if parent != "__ROOT__" else "root"
                
                all_children = "\n  ".join([
                    f"- '{p.title}' (nav_order={p.nav_order}) at {p.path}"
                    for p in sorted(group, key=lambda x: x.nav_order)
                ])
                
                raise DocError(
                    f"nav_order conflict under parent '{parent_display}':\n"
                    f"  '{page.title}' ({page.path}) and\n"
                    f"  '{other.title}' ({other.path})\n"
                    f"  both have nav_order={page.nav_order}\n\n"
                    f"All children under '{parent_display}':\n  {all_children}"
                )
            seen[page.nav_order] = page

def generate_tree(pages):
    """GÃ©nÃ¨re l'arborescence de navigation en format Markdown"""
    children = defaultdict(list)
    for page in pages.values():
        parent = page.parent or "__ROOT__"
        children[parent].append(page)
    
    # Trier les enfants par nav_order
    for parent in children:
        children[parent].sort(key=lambda p: p.nav_order)
    
    output_lines = [
        "# Documentation Navigation Tree",
        "",
        "> ğŸ¤– This file is auto-generated by `scripts/validate_nav.py`",
        "> Do not edit manually - it will be overwritten on next run",
        "",
        "## Navigation Structure",
        ""
    ]
    
    def render_tree(parent_key, level=0):
        """Rendu rÃ©cursif de l'arborescence"""
        if parent_key not in children:
            return
        
        for page in children[parent_key]:
            indent = "  " * level
            icon = "ğŸ“" if page.title in children else "ğŸ“„"
            rel_path = page.path.relative_to(DOCS_DIR)
            
            output_lines.append(
                f"{indent}- {icon} **{page.title}** "
                f"(order: {page.nav_order}) â†’ `{rel_path}`"
            )
            
            # RÃ©cursion pour les enfants
            render_tree(page.title, level + 1)
    
    # Commencer par la racine
    render_tree("__ROOT__")
    
    output_lines.extend([
        "",
        "---",
        "",
        "## Statistics",
        "",
        f"- Total pages: {len(pages)}",
        f"- Root pages: {len(children['__ROOT__'])}",
        f"- Max depth: {calculate_max_depth(pages, children)}",
    ])
    
    return "\n".join(output_lines)

def calculate_max_depth(pages, children):
    """Calcule la profondeur maximale de l'arborescence"""
    def depth(parent_key, current=0):
        if parent_key not in children:
            return current
        return max((depth(p.title, current + 1) for p in children[parent_key]), default=current)
    
    return depth("__ROOT__")

def main():
    try:
        print("ğŸ” Loading pages...")
        pages = load_pages()
        print(f"   âœ“ {len(pages)} pages loaded")
        
        print("\nğŸ” Validating structure...")
        validate_parents(pages)
        print("   âœ“ Parents are valid")
        
        detect_cycles(pages)
        print("   âœ“ No cycles detected")
        
        validate_nav_order(pages)
        print("   âœ“ nav_order values are unique per parent")
        
        print("\nğŸ“ Generating navigation tree...")
        tree_content = generate_tree(pages)
        
        OUTPUT_FILE.write_text(tree_content, encoding="utf-8")
        print(f"   âœ“ Navigation tree written to {OUTPUT_FILE}")
        
        print("\nâœ… Documentation navigation is valid and tree generated successfully")
        
    except DocError as e:
        print(f"\nâŒ Validation failed: {e}")
        exit(1)
    except Exception as e:
        print(f"\nâŒ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        exit(1)

if __name__ == "__main__":
    main()