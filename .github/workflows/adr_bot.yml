name: ADR Bot

on:
  issues:
    types: [opened, labeled, edited]
  discussion_comment:
    types: [created]
  discussion:
    types: [closed]

permissions:
  contents: write
  discussions: write

jobs:
  # Job 1: D√©tecter les issues qui n√©cessitent un ADR et cr√©er une discussion
  detect_and_create_discussion:
    name: Detect ADR need and create discussion
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'labeled')
    
    permissions:
      issues: write
      discussions: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Check if already has discussion
        id: check_existing
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            
            // V√©rifier si une discussion existe d√©j√† pour cette issue
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });
            
            const hasDiscussion = comments.data.some(c => 
              c.user.type === 'Bot' && 
              c.body.includes('üèõÔ∏è **ADR Discussion Created**')
            );
            
            return !hasDiscussion;
      
      - name: Analyze if ADR is needed
        if: fromJSON(steps.check_existing.outputs.result)
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            
            // Crit√®res de d√©tection d'un ADR
            const hasADRLabel = issue.labels.some(l => 
              ['adr', 'architecture', 'design-decision'].includes(l.name.toLowerCase())
            );
            
            const adrKeywords = [
              'architecture', 'architectural', 'design decision',
              'adr', 'technical decision', 'system design',
              'refactor', 'redesign', 'architectural choice'
            ];
            
            const titleLower = issue.title.toLowerCase();
            const bodyLower = (issue.body || '').toLowerCase();
            
            const hasKeywords = adrKeywords.some(kw => 
              titleLower.includes(kw) || bodyLower.includes(kw)
            );
            
            const isADR = hasADRLabel || hasKeywords;
            
            console.log(`Issue #${issue.number}: ADR detection = ${isADR}`);
            console.log(`  - Has ADR label: ${hasADRLabel}`);
            console.log(`  - Has keywords: ${hasKeywords}`);
            
            return {
              isADR: isADR,
              issueNumber: issue.number,
              issueTitle: issue.title,
              issueBody: issue.body || ''
            };
      
      - name: Get discussion category ID
        if: fromJSON(steps.check_existing.outputs.result) && fromJSON(steps.analyze.outputs.result).isADR
        id: get_category
        uses: actions/github-script@v7
        with:
          script: |
            // R√©cup√©rer toutes les cat√©gories de discussion
            const result = await github.graphql(`
              query($owner: String!, $repo: String!) {
                repository(owner: $owner, name: $repo) {
                  discussionCategories(first: 20) {
                    nodes {
                      id
                      name
                    }
                  }
                }
              }
            `, {
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            const categories = result.repository.discussionCategories.nodes;
            
            console.log('üìã Available discussion categories:');
            categories.forEach(cat => {
              console.log(`  - ${cat.name}: ${cat.id}`);
            });
            
            // Chercher la cat√©gorie "Architecture Decisions" (ou variantes)
            const possibleNames = [
              'Architecture Decisions',
              'Architecture Decision Records',
              'ADR',
              'Architectural Decisions',
              'architecture decisions',
              'adr'
            ];
            
            let category = categories.find(cat => 
              possibleNames.some(name => 
                cat.name.toLowerCase() === name.toLowerCase()
              )
            );
            
            // Si pas trouv√©e, utiliser la premi√®re cat√©gorie disponible
            if (!category && categories.length > 0) {
              category = categories[0];
              console.log(`‚ö†Ô∏è  No "Architecture Decisions" category found, using: ${category.name}`);
            }
            
            if (!category) {
              throw new Error('No discussion categories found! Please create at least one discussion category in your repository.');
            }
            
            console.log(`‚úÖ Using category: ${category.name} (${category.id})`);
            
            return {
              categoryId: category.id,
              categoryName: category.name
            };
      
      - name: Create ADR discussion
        if: fromJSON(steps.check_existing.outputs.result) && fromJSON(steps.analyze.outputs.result).isADR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADR_BOT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const analysis = ${{ steps.analyze.outputs.result }};
            const category = ${{ steps.get_category.outputs.result }};
            
            const discussionBody = `
            # üèõÔ∏è Architecture Decision Record Discussion
            
            **Related Issue**: #${analysis.issueNumber}
            **Status**: üü° Under Discussion
            
            ---
            
            ## üìã Original Issue Context
            
            ${analysis.issueBody}
            
            ---
            
            ## üìù How to fill this ADR
            
            Use the following commands to fill in the ADR sections:
            
            - \`/adr fill <section>\` - Fill or replace a section with content
            - \`/adr append <section>\` - Add content to an existing section
            - \`/adr show\` - Display the current state of the ADR
            - \`/adr show <section>\` - Display a specific section
            - \`/adr approve\` - Approve and generate the ADR document (maintainers only)
            - \`/adr reject\` - Reject this ADR (maintainers only)
            
            ### Example:
            
            \`\`\`
            /adr fill context
            We need to choose a database solution for our new microservices architecture.
            Currently using a monolithic PostgreSQL database which is becoming a bottleneck.
            Requirements: high availability, horizontal scalability, multi-region support.
            \`\`\`
            
            ---
            
            ## üìã Required Sections
            
            - **Context**: What is the problem or decision we need to make?
            - **Decision**: What solution are we proposing?
            - **Consequences**: What are the impacts (positive and negative)?
            
            ## üìã Optional Sections
            
            - **Alternatives**: What other options were considered?
            - **SafetyImpact**: Safety-related considerations (if applicable)
            - **Implementation**: How will this be implemented?
            
            ---
            
            ## üë• Participants
            
            Tag relevant stakeholders for review.
            `;
            
            try {
              console.log(`Creating discussion in category: ${category.categoryName}`);
              
              const result = await github.graphql(`
                mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
                  createDiscussion(input: {
                    repositoryId: $repositoryId,
                    categoryId: $categoryId,
                    title: $title,
                    body: $body
                  }) {
                    discussion {
                      id
                      number
                      url
                    }
                  }
                }
              `, {
                repositoryId: context.payload.repository.node_id,
                categoryId: category.categoryId,
                title: `[ADR] ${analysis.issueTitle}`,
                body: discussionBody
              });
              
              const discussion = result.createDiscussion.discussion;
              
              // Commenter sur l'issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: analysis.issueNumber,
                body: `üèõÔ∏è **ADR Discussion Created**
            
            This issue has been identified as requiring an Architecture Decision Record.
            
            üëâ **Join the discussion**: ${discussion.url}
            
            Please participate in the discussion to:
            - Fill in the ADR sections using \`/adr fill <section>\` commands
            - Use \`/adr show\` to preview the current state
            - Review and comment on the proposed architecture
            - Reach consensus with the team
            
            Once ready, a maintainer can approve with \`/adr approve\` to generate the final ADR document.
            
            **Discussion #${discussion.number}** | **Category**: ${category.categoryName}`
              });
              
              // Ajouter les labels
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: analysis.issueNumber,
                labels: ['adr', 'needs-review']
              });
              
              console.log(`‚úÖ Discussion created: #${discussion.number}`);
              
            } catch (error) {
              console.error('Error creating discussion:', error);
              
              // Si erreur, commenter sur l'issue pour expliquer
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: analysis.issueNumber,
                body: `‚ö†Ô∏è **ADR Discussion Creation Failed**
            
            Could not automatically create a discussion for this ADR.
            
            **Possible reasons:**
            - Discussions may not be enabled in this repository
            - No discussion categories exist
            
            **To fix:**
            1. Go to Settings ‚Üí Features ‚Üí Enable Discussions
            2. Create a discussion category (e.g., "Architecture Decisions")
            3. Re-run the workflow or manually create a discussion
            
            **Error**: ${error.message}`
              });
              
              throw error;
            }

  # Job 2: Traiter les commandes ADR dans les commentaires de discussion
  process_adr_commands:
    name: Process ADR Commands
    runs-on: ubuntu-latest
    if: github.event_name == 'discussion_comment'
    
    permissions:
      contents: write
      discussions: write

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Download previous ADR state
        id: download_state
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: adr-state-${{ github.event.discussion.number }}
          path: .

      - name: Fetch discussion comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");

            const discussionNumber = context.payload.discussion.number;

            const query = `
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  discussion(number: $number) {
                    comments(first: 100) {
                      nodes {
                        body
                        createdAt
                        author {
                          login
                        }
                      }
                    }
                  }
                }
              }
            `;

            const result = await github.graphql(query, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              number: discussionNumber
            });

            const comments = result.repository.discussion.comments.nodes;
            const enriched = [];

            for (const c of comments) {
              let role = "BOT";

              // Ignore les bots syst√®me
              if (c.author && c.author.login && c.author.login !== "github-actions") {
                try {
                  const perm = await github.rest.repos.getCollaboratorPermissionLevel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    username: c.author.login
                  });
                  role = perm.data.permission.toUpperCase();
                } catch (err) {
                  console.log(`‚ö†Ô∏è Permission lookup failed for ${c.author.login}, defaulting to READ`);
                  role = "READ";
                }
              }

              enriched.push({
                body: c.body,
                author: c.author?.login ?? "unknown",
                author_role: role,
                created_at: c.createdAt
              });
            }

            const payload = {
              meta: {
                discussion_number: discussionNumber,
                discussion_url: context.payload.discussion.html_url,
                title: context.payload.discussion.title
              },
              comments: enriched
            };

            fs.writeFileSync("input.json", JSON.stringify(payload, null, 2));
            console.log(`‚úÖ Saved ${enriched.length} comments to input.json`);

      - name: Run ADR bot
        id: run_bot
        run: |
          python scripts/adr_bot/main.py input.json
          
          # Lire le statut de sortie pour savoir si c'est une approbation ou un rejet
          if [ -f bot_output.json ]; then
            if grep -q '"adr_file"' bot_output.json; then
              echo "approved=true" >> $GITHUB_OUTPUT
              echo "rejected=false" >> $GITHUB_OUTPUT
              echo "‚úÖ ADR approved - will commit and cleanup"
            elif grep -q '"rejected": true' bot_output.json; then
              echo "approved=false" >> $GITHUB_OUTPUT
              echo "rejected=true" >> $GITHUB_OUTPUT
              echo "‚ùå ADR rejected - will cleanup"
            else
              echo "approved=false" >> $GITHUB_OUTPUT
              echo "rejected=false" >> $GITHUB_OUTPUT
              echo "üìù State updated - will save as artifact"
            fi
          else
            echo "approved=false" >> $GITHUB_OUTPUT
            echo "rejected=false" >> $GITHUB_OUTPUT
          fi

      - name: Post ADR bot feedback
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            if (!fs.existsSync("bot_output.json")) {
              console.log("No bot output to post");
              return;
            }

            const output = JSON.parse(fs.readFileSync("bot_output.json", "utf8"));

            let body = "";
            if (output.status === "error") {
              body = `‚ùå **ADR command failed**\n\n${output.message}`;
              if (output.details?.missing) {
                body += `\n\n**Missing required sections:**\n- ${output.details.missing.join("\n- ")}`;
              }
            } else if (output.status === "show") {
              body = `üìã **ADR Content**\n\n${output.content}`;
            } else if (output.status === "success") {
              body = `‚úÖ **ADR approved**\n\nGenerated file: \`${output.adr_file}\``;
            }

            const mutation = `
              mutation($discussionId: ID!, $body: String!) {
                addDiscussionComment(input: {
                  discussionId: $discussionId,
                  body: $body
                }) {
                  comment {
                    id
                  }
                }
              }
            `;

            await github.graphql(mutation, {
              discussionId: context.payload.discussion.node_id,
              body
            });

            console.log("ADR bot feedback posted");

      - name: Save ADR state as artifact
        if: steps.run_bot.outputs.approved != 'true' && steps.run_bot.outputs.rejected != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: adr-state-${{ github.event.discussion.number }}
          path: adr_state.json
          retention-days: 90
          overwrite: true

      - name: Commit ADR
        if: steps.run_bot.outputs.approved == 'true'
        run: |
          git config user.name "adr-bot"
          git config user.email "adr-bot@users.noreply.github.com"
          git add docs/adr/*.md adr_state.json || true
          git commit -m "docs(adr): publish ADR from discussion #${{ github.event.discussion.number }}" || true
          git push
          
      - name: Cleanup artifact after approval
        if: steps.run_bot.outputs.approved == 'true' || steps.run_bot.outputs.rejected == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            // Supprimer l'artifact apr√®s approbation/rejet car on n'en a plus besoin
            const artifactName = `adr-state-${{ github.event.discussion.number }}`;
            const action = '${{ steps.run_bot.outputs.approved }}' === 'true' ? 'approved' : 'rejected';
            console.log(`Cleaning up artifact after ADR was ${action}: ${artifactName}`);
            
            try {
              const artifacts = await github.rest.actions.listArtifactsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              
              const artifact = artifacts.data.artifacts.find(a => a.name === artifactName);
              if (artifact) {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
                console.log(`‚úÖ Artifact ${artifactName} deleted`);
              } else {
                console.log(`‚ÑπÔ∏è  No artifact found to delete`);
              }
            } catch (error) {
              console.log(`‚ö†Ô∏è Could not delete artifact: ${error.message}`);
            }